/*
 * Fixed SAI APIs which are not based on P4 pipeline code.
 * Just sufficient to support testing & integrating bmv2's libsai.
 */
#include "utils.h"
#include "saiimpl.h"

// TODO to be moved to separate class/namespace

static std::shared_ptr<grpc::Channel> _grpcChannel;
extern std::unique_ptr<p4::v1::P4Runtime::Stub> stub;

#define DASH_BMV2_NUM_PORTS 2
#define DASH_BMV2_CPU_QOS_NUMBER_OF_QUEUES 0

#define DASH_OBJECT_SHFT 48
#define DASH_MAKE_OID(_objtype, _objval) (sai_object_id_t)(((sai_object_id_t)_objtype<<DASH_OBJECT_SHFT)+(sai_object_id_t)_objval)

#define DASH_BMV2_DEFAULT_CPU_PORT_ID DASH_MAKE_OID(SAI_OBJECT_TYPE_PORT,64)
#define DASH_BMV2_DEFAULT_VLAN_ID DASH_MAKE_OID(SAI_OBJECT_TYPE_VLAN,1)
#define DASH_BMV2_DEFAULT_VRF_ID DASH_MAKE_OID(SAI_OBJECT_TYPE_VIRTUAL_ROUTER,1)
#define DASH_BMV2_DEFAULT_1Q_BRIDGE_ID DASH_MAKE_OID(SAI_OBJECT_TYPE_BRIDGE,1)

static sai_object_id_t port_list[DASH_BMV2_NUM_PORTS] = {
    DASH_MAKE_OID(SAI_OBJECT_TYPE_PORT,1),
    DASH_MAKE_OID(SAI_OBJECT_TYPE_PORT,2)
};

static sai_status_t dash_sai_create_switch(
        _Out_ sai_object_id_t *switch_id,
        _In_ uint32_t attr_count,
        _In_ const sai_attribute_t *attr_list)
{
    DASH_LOG_ENTER();

    *switch_id = DASH_MAKE_OID(SAI_OBJECT_TYPE_SWITCH,1),

    DASH_LOG_NOTICE("created switch id: %ld", *switch_id);

    return SAI_STATUS_SUCCESS;
}

static sai_status_t dash_sai_get_switch_attribute(
        _In_ sai_object_id_t switch_id,
        _In_ uint32_t attr_count,
        _Inout_ sai_attribute_t *attr_list)
{
    DASH_LOG_ENTER();

    DASH_LOG_NOTICE("dash_get_switch_attribute()");

    sai_attribute_t *attr = attr_list;

    for (uint32_t i = 0; i < attr_count ; i++, attr++)
    {
        switch(attr->id)
        {
            case SAI_SWITCH_ATTR_NUMBER_OF_ACTIVE_PORTS:

                attr->value.u32 = DASH_BMV2_NUM_PORTS;

                DASH_LOG_NOTICE("[%d] attr %d SAI_SWITCH_ATTR_NUMBER_OF_ACTIVE_PORTS = %d", i, attr->id, attr->value.u32);

                break;

            case SAI_SWITCH_ATTR_PORT_LIST:

                attr->value.objlist.count = DASH_BMV2_NUM_PORTS;

                for (uint32_t j = 0; j < DASH_BMV2_NUM_PORTS; j++)
                {
                    attr->value.objlist.list[j] = port_list[j];
                }

                DASH_LOG_NOTICE("[%d] attr %d SAI_SWITCH_ATTR_PORT_LIST = [%d objids]", i, attr->id, DASH_BMV2_NUM_PORTS);

                break;

            case SAI_SWITCH_ATTR_DEFAULT_VLAN_ID:

                attr->value.oid = DASH_BMV2_DEFAULT_VLAN_ID;

                DASH_LOG_NOTICE("[%d] attr %d SAI_SWITCH_ATTR_DEFAULT_VLAN_ID = %lx", i, attr->id, attr->value.oid);

                break;

            case SAI_SWITCH_ATTR_DEFAULT_VIRTUAL_ROUTER_ID:

                attr->value.oid = DASH_BMV2_DEFAULT_VRF_ID;

                DASH_LOG_NOTICE("attr %d SAI_SWITCH_ATTR_DEFAULT_VIRTUAL_ROUTER_ID = %lx", attr->id, attr->value.oid);

                break;

            case SAI_SWITCH_ATTR_DEFAULT_1Q_BRIDGE_ID:

                attr->value.oid = DASH_BMV2_DEFAULT_1Q_BRIDGE_ID;

                DASH_LOG_NOTICE("attr %d SAI_SWITCH_ATTR_DEFAULT_1Q_BRIDGE_ID = %lx", attr->id, attr->value.oid);

                break;

            case SAI_SWITCH_ATTR_CPU_PORT:

                attr->value.oid = DASH_BMV2_DEFAULT_CPU_PORT_ID;

                DASH_LOG_NOTICE("[%d] attr %d DASH_BMV2_DEFAULT_CPU_PORT_ID = %lx", i, attr->id, attr->value.oid);

                break;

            default:

                DASH_LOG_WARN("attr %d is NOT SUPPORTED, but returning SAI_STATUS_SUCCESS", attr->id);

                memset(&attr->value, 0, sizeof(attr->value)); // clear potential caller garbage

                break; // TODO FIXME should return NOT SUPPORTED
        }
    }

    return SAI_STATUS_SUCCESS;
}

sai_switch_api_t dash_sai_switch_api_impl = {
    .create_switch = dash_sai_create_switch,
    .remove_switch = 0,
    .set_switch_attribute = 0,
    .get_switch_attribute = dash_sai_get_switch_attribute,
    .get_switch_stats = 0,
    .get_switch_stats_ext = 0,
    .clear_switch_stats = 0,
    .switch_mdio_read = 0,
    .switch_mdio_write = 0,
    .create_switch_tunnel = 0,
    .remove_switch_tunnel = 0,
    .set_switch_tunnel_attribute = 0,
    .get_switch_tunnel_attribute = 0,
};

static sai_status_t dash_sai_get_port_attribute(
        _In_ sai_object_id_t port_id,
        _In_ uint32_t attr_count,
        _Inout_ sai_attribute_t *attr_list)
{
    DASH_LOG_ENTER();

    DASH_LOG_NOTICE("dash_sai_get_port_attribute()");

    sai_attribute_t *attr = attr_list;

    for (uint32_t i = 0; i < attr_count ; i++, attr++)
    {
        switch(attr->id)
        {
            case SAI_PORT_ATTR_QOS_NUMBER_OF_QUEUES:

                attr->value.u32 = DASH_BMV2_CPU_QOS_NUMBER_OF_QUEUES;

                DASH_LOG_NOTICE("attr %d SAI_PORT_ATTR_QOS_NUMBER_OF_QUEUES = %d", attr->id, attr->value.u32);

                break;

            default:

                DASH_LOG_WARN("attr %d is NOT SUPPORTED, but returning SAI_STATUS_SUCCESS", attr->id);

                memset(&attr->value, 0, sizeof(attr->value)); // clear potential caller garbage

                break; // TODO FIXME should return NOT SUPPORTED
        }
    }

    return SAI_STATUS_SUCCESS;
}

sai_port_api_t dash_sai_port_api_impl = {
    .create_port = 0,
    .remove_port = 0,
    .set_port_attribute = 0,
    .get_port_attribute = dash_sai_get_port_attribute,
    .get_port_stats = 0,
    .get_port_stats_ext = 0,
    .clear_port_stats = 0,
    .clear_port_all_stats = 0,
    .create_port_pool = 0,
    .remove_port_pool = 0,
    .set_port_pool_attribute = 0,
    .get_port_pool_attribute = 0,
    .get_port_pool_stats = 0,
    .get_port_pool_stats_ext = 0,
    .clear_port_pool_stats = 0,
    .create_port_connector = 0,
    .remove_port_connector = 0,
    .set_port_connector_attribute = 0,
    .get_port_connector_attribute = 0,
    .create_port_serdes = 0,
    .remove_port_serdes = 0,
    .set_port_serdes_attribute = 0,
    .get_port_serdes_attribute = 0,
    .create_ports = 0,
    .remove_ports = 0,
    .set_ports_attribute = 0,
    .get_ports_attribute = 0
};

sai_status_t sai_api_query(
        _In_ sai_api_t api,
        _Out_ void **api_method_table)
{
    DASH_LOG_ENTER();

    switch((int)api) {
        case SAI_API_SWITCH:
            *api_method_table = (void *)&dash_sai_switch_api_impl;
            break;

        case SAI_API_PORT:
            *api_method_table = (void *)&dash_sai_port_api_impl;
            break;

{% for api in api_names %}
        case SAI_API_{{ api | upper }}:
            *api_method_table = (void *)&dash_sai_{{ api }}_api_impl;
            break;

{% endfor %}
        default:

            DASH_LOG_WARN("api %d not supported", api);

            return SAI_STATUS_NOT_SUPPORTED;
    }

    return SAI_STATUS_SUCCESS;
}

sai_status_t sai_object_type_get_availability(
        _In_ sai_object_id_t switch_id,
        _In_ sai_object_type_t object_type,
        _In_ uint32_t attr_count,
        _In_ const sai_attribute_t *attr_list,
        _Out_ uint64_t *count)
{
    DASH_LOG_ENTER();

    DASH_LOG_WARN("not implemented");

    return SAI_STATUS_NOT_IMPLEMENTED;
}

sai_object_type_t sai_object_type_query(
        _In_ sai_object_id_t object_id)
{
    DASH_LOG_ENTER();

    return sai_object_type_t(object_id>>DASH_OBJECT_SHFT);
}

sai_object_id_t sai_switch_id_query(
        _In_ sai_object_id_t object_id)
{
    DASH_LOG_ENTER();

    if (object_id == SAI_NULL_OBJECT_ID)
    {
        return SAI_NULL_OBJECT_ID;
    }

    return DASH_MAKE_OID(SAI_OBJECT_TYPE_SWITCH,1);
}

sai_status_t sai_query_attribute_enum_values_capability(
        _In_ sai_object_id_t switch_id,
        _In_ sai_object_type_t object_type,
        _In_ sai_attr_id_t attr_id,
        _Inout_ sai_s32_list_t *enum_values_capability)
{
    DASH_LOG_ENTER();

    DASH_LOG_WARN("not implemented");

    return SAI_STATUS_NOT_IMPLEMENTED;
}

static p4::config::v1::P4Info parse_p4info(const char *path)
{
    DASH_LOG_ENTER();

    p4::config::v1::P4Info p4info;
    std::ifstream istream(path);
    assert(istream.good());
    google::protobuf::io::IstreamInputStream istream_(&istream);
    google::protobuf::TextFormat::Parse(&istream_, &p4info);

    return p4info;
}

sai_status_t sai_api_initialize(
        _In_ uint64_t flags,
        _In_ const sai_service_method_table_t *services)
{
    DASH_LOG_ENTER();

    const grpc::string _grpcTarget = "0.0.0.0:9559";
    char test_json[] = "/etc/dash/dash_pipeline.json";
    char test_proto_json[] = "/etc/dash/dash_pipeline_p4rt.txt";
    int dev_id = 0;

    DASH_LOG_NOTICE("GRPC call SetForwardingPipelineConfig %s => %s, %s", _grpcTarget.c_str(), test_json, test_proto_json);

    auto p4info = parse_p4info(test_proto_json);

    auto set_election_id = [](p4::v1::Uint128 *election_id) {
        election_id->set_high(0);
        election_id->set_low(1);
    };

    grpc::ClientContext stream_context;
    _grpcChannel = grpc::CreateChannel(_grpcTarget, grpc::InsecureChannelCredentials());
    stub = p4::v1::P4Runtime::NewStub(_grpcChannel);
    auto stream = stub->StreamChannel(&stream_context);
    {
        p4::v1::StreamMessageRequest request;
        auto arbitration = request.mutable_arbitration();
        arbitration->set_device_id(dev_id);
        set_election_id(arbitration->mutable_election_id());
        stream->Write(request);
        p4::v1::StreamMessageResponse response;
        stream->Read(&response);
        assert(response.update_case() == p4::v1::StreamMessageResponse::kArbitration);
        assert(response.arbitration().status().code() == ::google::rpc::Code::OK);
    }
    {
        p4::v1::SetForwardingPipelineConfigRequest request;
        request.set_device_id(dev_id);
        request.set_action(
                p4::v1::SetForwardingPipelineConfigRequest_Action_VERIFY_AND_COMMIT);
        set_election_id(request.mutable_election_id());
        auto config = request.mutable_config();
        config->set_allocated_p4info(&p4info);
        std::ifstream istream(test_json);
        config->mutable_p4_device_config()->assign(
                (std::istreambuf_iterator<char>(istream)),
                 std::istreambuf_iterator<char>());

        p4::v1::SetForwardingPipelineConfigResponse rep;
        grpc::ClientContext context;

        auto status = stub->SetForwardingPipelineConfig(
                &context, request, &rep);
        assert(status.ok());
        config->release_p4info();
    }

    return SAI_STATUS_SUCCESS;
}

sai_status_t sai_api_uninitialize(void)
{
    DASH_LOG_ENTER();

    // TODO delete stub

    return SAI_STATUS_SUCCESS;
}

sai_status_t sai_log_set(
        _In_ sai_api_t api,
        _In_ sai_log_level_t log_level)
{
    DASH_LOG_ENTER();

    return SAI_STATUS_SUCCESS;
}

sai_status_t sai_query_api_version(
        _Out_ sai_api_version_t *version)
{
    DASH_LOG_ENTER();

    if (version)
    {
        *version = SAI_API_VERSION;

        return SAI_STATUS_SUCCESS;
    }

    DASH_LOG_ERROR("version parameter is NULL");

    return SAI_STATUS_INVALID_PARAMETER;
}

sai_status_t sai_query_stats_capability(
        _In_ sai_object_id_t switch_id,
        _In_ sai_object_type_t object_type,
        _Inout_ sai_stat_capability_list_t *stats_capability)
{
    DASH_LOG_ENTER();

    DASH_LOG_WARN("not implemented");

    return SAI_STATUS_NOT_IMPLEMENTED;
}

sai_status_t sai_query_attribute_capability(
        _In_ sai_object_id_t switch_id,
        _In_ sai_object_type_t object_type,
        _In_ sai_attr_id_t attr_id,
        _Out_ sai_attr_capability_t *attr_capability)
{
    DASH_LOG_ENTER();

    DASH_LOG_WARN("not implemented");

    return SAI_STATUS_NOT_IMPLEMENTED;
}

sai_status_t sai_dbg_generate_dump(
        _In_ const char *dump_file_name)
{
    DASH_LOG_ENTER();

    DASH_LOG_WARN("not implemented");

    return SAI_STATUS_NOT_IMPLEMENTED;
}
