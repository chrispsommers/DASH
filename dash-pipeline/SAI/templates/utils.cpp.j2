#include "utils.h"

static int deviceId = 0;

static std::unordered_multimap<sai_object_id_t, p4::v1::TableEntry *> tableEntryMap;
static std::mutex tableLock;
static std::atomic<sai_object_id_t> nextId;

std::unique_ptr<p4::v1::P4Runtime::Stub> stub;

void correctIpPrefix(void *ip, const void *mask, size_t length)
{
    auto _ip = reinterpret_cast<uint8_t *>(ip);
    auto _mask = reinterpret_cast<const uint8_t *>(mask);
    for (size_t i = 0; i < length; i++)
    {
        _ip[i] = _ip[i] & _mask[i];
    }
}

int leadingNonZeroBits(const uint32_t ipv4) {
    auto firstSetBit  = __builtin_ffs(ipv4);
    if (0==firstSetBit) {
        return 0;
    }
    return 33 -  firstSetBit;
}

int leadingNonZeroBits(const sai_ip6_t ipv6) {
    int trailingZeros = 0;
    for (int i = 0; i < 16; i+=4) {
        auto num = static_cast<uint32_t>(ipv6[i]) +
        (static_cast<uint32_t>(ipv6[i+1]) << 8) +
        (static_cast<uint32_t>(ipv6[i+2]) << 16) +
        (static_cast<uint32_t>(ipv6[i+3]) << 24);
        auto firstSetBit  = leadingNonZeroBits(num);
        if (firstSetBit > 0) {
            return 129-trailingZeros-firstSetBit;
        }
        trailingZeros += 32;
    }
    return 0;
}


int GetDeviceId()
{
    DASH_LOG_ENTER();

    return deviceId;
}

std::string updateTypeStr(p4::v1::Update_Type updateType) {
    const google::protobuf::EnumDescriptor *descriptor = p4::v1::Update_Type_descriptor();
    return descriptor->FindValueByNumber(updateType)->name();
}

const sai_attribute_t *getMaskAttr(sai_attr_id_t id, uint32_t attr_count, const sai_attribute_t *attr_list) {
    for (uint32_t i = 0; i < attr_count; i++) {
        if (attr_list[i].id == id) {
            return &attr_list[i];
        }
    }
    return nullptr;
}

grpc::StatusCode MutateTableEntry(p4::v1::TableEntry *entry, p4::v1::Update_Type updateType)
{
    DASH_LOG_ENTER();

    p4::v1::WriteRequest request;
    request.set_device_id(GetDeviceId());
    auto update = request.add_updates();
    update->set_type(updateType);
    auto entity = update->mutable_entity();
    entity->set_allocated_table_entry(entry);

    p4::v1::WriteResponse rep;
    grpc::ClientContext context;
    grpc::Status status = stub->Write(&context, request, &rep);

    if (status.ok())
    {
        DASH_LOG_NOTICE("GRPC call Write::%s OK %s", updateTypeStr(updateType).c_str(), entry->ShortDebugString().c_str());
    }
    else
    {
        DASH_LOG_ERROR("GRPC ERROR[%d]: %s, %s", status.error_code(), status.error_message().c_str(), status.error_details().c_str());
        DASH_LOG_ERROR("GRPC call Write::%s ERROR: %s", updateTypeStr(updateType).c_str(), entry->ShortDebugString().c_str());
    }

    //MILIND?? What is this? reference release? memory release?
    entity->release_table_entry();
    return status.error_code();
}

bool InsertInTable(p4::v1::TableEntry *entry, sai_object_id_t *objId)
{
    DASH_LOG_ENTER();

    auto retCode = MutateTableEntry(entry, p4::v1::Update_Type_INSERT);
    if (grpc::StatusCode::OK != retCode) {
        return false;
    }

    std::lock_guard<std::mutex> lock(tableLock);

    if (*objId == 0)
    {
        *objId = NextObjIndex();
    }
    tableEntryMap.insert(std::make_pair(*objId, entry));
    return true;
}

sai_object_id_t NextObjIndex()
{
    DASH_LOG_ENTER();

    return ++nextId;
}

bool RemoveFromTable(sai_object_id_t id)
{
    DASH_LOG_ENTER();

    std::lock_guard<std::mutex> lock(tableLock);
    auto range = tableEntryMap.equal_range(id);
    if (range.first == range.second)
    {
        DASH_LOG_ERROR("id: %ld not present in the table for deletion!", id);

        return false;
    }

    grpc::StatusCode retCode = grpc::StatusCode::OK;

    for (auto itr = range.first; itr != range.second; ++itr) {
        auto entry = itr->second;
        auto tempRet = MutateTableEntry(entry, p4::v1::Update_Type_DELETE);
        if (grpc::StatusCode::OK != tempRet) {
            retCode = tempRet;
        }
        delete entry;
    }

    tableEntryMap.erase(id);
    return retCode == grpc::StatusCode::OK;
}
